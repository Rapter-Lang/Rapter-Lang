// ============================================================================
// TYPECHECKER.RAPT - Type Checker for Rapter Bootstrap Compiler
// ============================================================================
// Performs semantic analysis and type checking on AST
// Uses Result<T,E> for error reporting
// ============================================================================

import bootstrap.src.ast_v2 as ast

extern fn printf(format: *char, ...) -> int;
extern fn strcmp(s1: *char, s2: *char) -> int;
extern fn strlen(s: *char) -> int;

// ============================================================================
// Type Environment - tracks variable and function types
// ============================================================================

struct SymbolEntry {
    name: *char,
    sym_type: *void,
    kind: int
}

struct TypeEnvironment {
    symbols: DynamicArray[SymbolEntry],
    parent: *TypeEnvironment
}

// ============================================================================
// Type Environment Operations
// ============================================================================

export fn make_env() -> TypeEnvironment {
    let empty_symbols = DynamicArray[SymbolEntry]();
    
    return TypeEnvironment {
        symbols: empty_symbols,
        parent: 0 as *TypeEnvironment
    };
}

export fn env_push_scope(env: *TypeEnvironment) -> TypeEnvironment {
    let empty_symbols = DynamicArray[SymbolEntry]();
    
    return TypeEnvironment {
        symbols: empty_symbols,
        parent: env
    };
}

export fn env_add_symbol(env: *TypeEnvironment, name: *char, sym_type: *void, kind: int) {
    let entry = SymbolEntry { name: name, sym_type: sym_type, kind: kind };
    env.symbols.push(entry);
}

export fn env_lookup(env: *TypeEnvironment, name: *char) -> *void {
    // Search current scope
    let i = 0;
    let count: int = env.symbols.length();
    for i : 0..count {
        let entry: SymbolEntry = env.symbols[i];
        if strcmp(entry.name, name) == 0 {
            return entry.sym_type;
        }
    }
    
    // Search parent scope
    if env.parent != (0 as *TypeEnvironment) {
        return env_lookup(env.parent, name);
    }
    
    return 0 as *void;
}

// ============================================================================
// Type Comparison
// ============================================================================

export fn types_equal(t1: *void, t2: *void) -> int {
    // Cast to AstType for comparison
    let type1 = t1 as *ast.AstType;
    let type2 = t2 as *ast.AstType;
    
    // Both null = equal
    if type1 == (0 as *ast.AstType) {
        if type2 == (0 as *ast.AstType) {
            return 1;
        } else {
            return 0;
        }
    }
    
    if type2 == (0 as *ast.AstType) {
        return 0;
    }
    
    // Different kinds = not equal
    if type1.kind != type2.kind {
        return 0;
    }
    
    // For basic types, kind is enough
    if type1.kind == 0 {
        return 1;
    }
    
    // For named types, compare names
    if type1.kind == 3 {
        return strcmp(type1.name, type2.name) == 0;
    }
    
    // For pointer types, compare inner types
    if type1.kind == 2 {
        return types_equal(type1.inner as *void, type2.inner as *void);
    }
    
    return 1;
}

// ============================================================================
// Type Checking Functions
// ============================================================================

export fn check_parameter(env: *TypeEnvironment, param: ast.Parameter) -> Result<int, str> {
    // Add parameter to environment
    env_add_symbol(env, param.name, param.param_type as *void, 2);
    
    printf("  - Parameter: %s: ", param.name);
    ast.print_type(param.param_type);
    printf("\n");
    
    return Result::Ok(1);
}

export fn check_let_statement(env: *TypeEnvironment, stmt: *ast.LetStatement) -> Result<int, str> {
    printf("  - Let statement: %s\n", stmt.name);
    
    // Add variable to environment
    env_add_symbol(env, stmt.name, stmt.var_type as *void, 0);
    
    return Result::Ok(1);
}

export fn check_return_statement(env: *TypeEnvironment, expected_return: *void) -> Result<int, str> {
    printf("  - Return statement\n");
    
    return Result::Ok(1);
}

export fn check_statement(env: *TypeEnvironment, stmt: ast.Statement, expected_return: *void) -> Result<int, str> {
    if stmt.kind == 0 {  // let statement
        let let_stmt: *ast.LetStatement = stmt.data as *ast.LetStatement;
        let _result: int = check_let_statement(env, let_stmt)?;
        return Result::Ok(1);
    } else {
        if stmt.kind == 1 {  // return statement
            let _result: int = check_return_statement(env, expected_return)?;
            return Result::Ok(1);
        } else {
            // Other statement types
            printf("  - Other statement (kind=%d)\n", stmt.kind);
            return Result::Ok(1);
        }
    }
}

export fn check_function(env: *TypeEnvironment, func: ast.Function) -> Result<int, str> {
    printf("\nChecking function: %s\n", func.name);
    
    // Create new scope for function
    let func_env = env_push_scope(env);
    let func_env_ptr = &func_env;
    
    // Check parameters
    let i = 0;
    let param_count: int = func.params.length();
    for i : 0..param_count {
        let _result: int = check_parameter(func_env_ptr, func.params[i])?;
    }
    
    // Check statements in body
    let j = 0;
    let stmt_count: int = func.body.length();
    for j : 0..stmt_count {
        let _result: int = check_statement(func_env_ptr, func.body[j], func.return_type as *void)?;
    }
    
    printf("✓ Function %s type-checked successfully\n", func.name);
    return Result::Ok(1);
}

export fn check_struct_field(field: ast.StructField) -> Result<int, str> {
    printf("  - Field: %s: ", field.name);
    ast.print_type(field.field_type);
    printf("\n");
    
    // In full implementation: verify field type is valid
    
    return Result::Ok(1);
}

export fn check_struct(env: *TypeEnvironment, struct_decl: ast.StructDecl) -> Result<int, str> {
    printf("\nChecking struct: %s\n", struct_decl.name);
    
    // Add struct to environment
    let struct_type = ast.make_named_type(struct_decl.name);
    env_add_symbol(env, struct_decl.name, struct_type as *void, 1);
    
    // Check all fields
    let i = 0;
    let field_count: int = struct_decl.fields.length();
    for i : 0..field_count {
        let _result: int = check_struct_field(struct_decl.fields[i])?;
    }
    
    printf("✓ Struct %s type-checked successfully\n", struct_decl.name);
    return Result::Ok(1);
}

export fn check_import(imp: ast.Import) -> Result<int, str> {
    printf("Checking import: %s\n", imp.module_path);
    
    // In full implementation: verify module exists and is accessible
    
    return Result::Ok(1);
}

export fn check_export(env: *TypeEnvironment, exp: ast.Export) -> Result<int, str> {
    printf("Checking export: %s\n", exp.name);
    
    // Verify exported item exists in environment
    let found_type = env_lookup(env, exp.name);
    
    if found_type == (0 as *void) {
        printf("  WARNING: Exported item '%s' not found in environment\n", exp.name);
    }
    
    return Result::Ok(1);
}

export fn check_program(prog: ast.Program) -> Result<int, str> {
    printf("\n=== Type Checking Program ===\n");
    
    // Create global environment
    let env = make_env();
    let env_ptr = &env;
    
    // Check imports
    printf("\n--- Imports ---\n");
    let i = 0;
    let import_count: int = prog.imports.length();
    for i : 0..import_count {
        let _result: int = check_import(prog.imports[i])?;
    }
    
    // Check structs (first pass - add to environment)
    printf("\n--- Structs ---\n");
    let j = 0;
    let struct_count: int = prog.structs.length();
    for j : 0..struct_count {
        let _result: int = check_struct(env_ptr, prog.structs[j])?;
    }
    
    // Check functions
    printf("\n--- Functions ---\n");
    let k = 0;
    let func_count: int = prog.functions.length();
    for k : 0..func_count {
        // Add function to environment first
        let func = prog.functions[k];
        let func_type = func.return_type;
        env_add_symbol(env_ptr, func.name, func_type as *void, 1);
        
        // Then check function body
        let _result: int = check_function(env_ptr, func)?;
    }
    
    // Check exports
    printf("\n--- Exports ---\n");
    let m = 0;
    let export_count: int = prog.exports.length();
    for m : 0..export_count {
        let _result: int = check_export(env_ptr, prog.exports[m])?;
    }
    
    printf("\n=== ✓ Type Checking Complete! ===\n\n");
    return Result::Ok(1);
}

// ============================================================================
// Error Reporting Helpers
// ============================================================================

export fn report_type_error(expected: *void, actual: *void, context: *char) -> Result<int, str> {
    printf("TYPE ERROR in %s:\n", context);
    printf("  Expected: ");
    ast.print_type(expected as *ast.AstType);
    printf("\n  Actual: ");
    ast.print_type(actual as *ast.AstType);
    printf("\n");
    
    return Result::Err("type mismatch");
}

export fn report_undefined_error(name: *char, context: *char) -> Result<int, str> {
    printf("UNDEFINED ERROR in %s:\n", context);
    printf("  Undefined identifier: %s\n", name);
    
    return Result::Err("undefined identifier");
}
