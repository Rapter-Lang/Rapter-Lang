// ============================================================================
// PARSER_V2.RAPT - Enhanced parser with Result<T,E> error handling
// ============================================================================
// Modern recursive descent parser using Result and ? operator
// ============================================================================

import token

extern fn printf(format: *char, ...) -> int;
extern fn strlen(s: *char) -> int;

// ============================================================================
// Parser State
// ============================================================================

struct Parser {
    tokens: DynamicArray[Token],
    current: int,
    input: *char
}

// ============================================================================
// Helper Functions
// ============================================================================

fn peek(p: *Parser) -> Token {
    if p.current < p.tokens.length() {
        return p.tokens[p.current];
    } else {
        let eof_span = Span { start: 0, end: 0 };
        return Token { kind: token.TK_EOF(), span: eof_span };
    }
}

fn advance(p: *Parser) -> Token {
    let tok = peek(p);
    if p.current < p.tokens.length() {
        p.current = p.current + 1;
    }
    return tok;
}

fn is_at_end(p: *Parser) -> int {
    let tok = peek(p);
    return tok.kind == token.TK_EOF();
}

fn check(p: *Parser, kind: int) -> int {
    if is_at_end(p) != 0 {
        return 0;
    }
    let tok = peek(p);
    return tok.kind == kind;
}

fn match_token(p: *Parser, kind: int) -> int {
    if check(p, kind) != 0 {
        let _ = advance(p);
        return 1;
    }
    return 0;
}

fn expect(p: *Parser, kind: int, message: *char) -> Result<Token, str> {
    if check(p, kind) != 0 {
        return Result::Ok(advance(p));
    } else {
        return Result::Err(message);
    }
}

fn get_token_text(p: *Parser, tok: Token) -> *char {
    return p.input;
}

// ============================================================================
// Expression Parsing (Simplified for Bootstrap)
// ============================================================================

fn parse_primary(p: *Parser) -> Result<int, str> {
    let tok = peek(p);
    
    if tok.kind == token.TK_INTEGER() {
        let _ = advance(p);
        return Result::Ok(1);
    }
    
    if tok.kind == token.TK_IDENT() {
        let _ = advance(p);
        return Result::Ok(1);
    }
    
    if tok.kind == token.TK_LPAREN() {
        let _ = advance(p);
        let _expr: int = parse_expression(p)?;
        let _rparen: Token = expect(p, token.TK_RPAREN(), "expected ')'")?;
        return Result::Ok(1);
    }
    
    return Result::Err("expected expression");
}

fn parse_expression(p: *Parser) -> Result<int, str> {
    return parse_primary(p);
}

// ============================================================================
// Statement Parsing
// ============================================================================

fn parse_let_statement(p: *Parser) -> Result<int, str> {
    let _let_tok: Token = expect(p, token.TK_LET(), "expected 'let'")?;
    let _ident: Token = expect(p, token.TK_IDENT(), "expected identifier")?;
    
    if match_token(p, token.TK_COLON()) != 0 {
        let _type_tok: Token = expect(p, token.TK_IDENT(), "expected type")?;
    }
    
    if match_token(p, token.TK_EQ()) != 0 {
        let _expr: int = parse_expression(p)?;
    }
    
    let _semi: Token = expect(p, token.TK_SEMI(), "expected ';'")?;
    return Result::Ok(1);
}

fn parse_return_statement(p: *Parser) -> Result<int, str> {
    let _ret_tok: Token = expect(p, token.TK_RETURN(), "expected 'return'")?;
    
    if check(p, token.TK_SEMI()) == 0 {
        let _expr: int = parse_expression(p)?;
    }
    
    let _semi: Token = expect(p, token.TK_SEMI(), "expected ';'")?;
    return Result::Ok(1);
}

fn parse_statement(p: *Parser) -> Result<int, str> {
    if check(p, token.TK_LET()) != 0 {
        return parse_let_statement(p);
    }
    
    if check(p, token.TK_RETURN()) != 0 {
        return parse_return_statement(p);
    }
    
    let _expr: int = parse_expression(p)?;
    let _semi: Token = expect(p, token.TK_SEMI(), "expected ';'")?;
    return Result::Ok(1);
}

fn parse_block(p: *Parser) -> Result<int, str> {
    let _lbrace: Token = expect(p, token.TK_LBRACE(), "expected '{'")?;
    
    let mut count = 0;
    while check(p, token.TK_RBRACE()) == 0 && is_at_end(p) == 0 {
        let _stmt: int = parse_statement(p)?;
        count = count + 1;
    }
    
    let _rbrace: Token = expect(p, token.TK_RBRACE(), "expected '}'")?;
    return Result::Ok(count);
}

// ============================================================================
// Function Parsing
// ============================================================================

fn parse_parameter(p: *Parser) -> Result<int, str> {
    let _name: Token = expect(p, token.TK_IDENT(), "expected parameter name")?;
    let _colon: Token = expect(p, token.TK_COLON(), "expected ':'")?;
    let _type: Token = expect(p, token.TK_IDENT(), "expected type")?;
    return Result::Ok(1);
}

fn parse_parameter_list(p: *Parser) -> Result<int, str> {
    let _lparen: Token = expect(p, token.TK_LPAREN(), "expected '('")?;
    
    let mut count = 0;
    if check(p, token.TK_RPAREN()) == 0 {
        let _param: int = parse_parameter(p)?;
        count = count + 1;
        
        while match_token(p, token.TK_COMMA()) != 0 {
            let _param2: int = parse_parameter(p)?;
            count = count + 1;
        }
    }
    
    let _rparen: Token = expect(p, token.TK_RPAREN(), "expected ')'")?;
    return Result::Ok(count);
}

fn parse_function(p: *Parser) -> Result<int, str> {
    let _fn_tok: Token = expect(p, token.TK_FN(), "expected 'fn'")?;
    let _name: Token = expect(p, token.TK_IDENT(), "expected function name")?;
    
    let _param_count: int = parse_parameter_list(p)?;
    
    if match_token(p, token.TK_ARROW()) != 0 {
        let _ret_type: Token = expect(p, token.TK_IDENT(), "expected return type")?;
    }
    
    let _stmt_count: int = parse_block(p)?;
    
    return Result::Ok(1);
}

// ============================================================================
// Struct Parsing
// ============================================================================

fn parse_struct_field(p: *Parser) -> Result<int, str> {
    let _name: Token = expect(p, token.TK_IDENT(), "expected field name")?;
    let _colon: Token = expect(p, token.TK_COLON(), "expected ':'")?;
    let _type: Token = expect(p, token.TK_IDENT(), "expected field type")?;
    let _comma: Token = expect(p, token.TK_COMMA(), "expected ','")?;
    return Result::Ok(1);
}

fn parse_struct(p: *Parser) -> Result<int, str> {
    let _struct_tok: Token = expect(p, token.TK_STRUCT(), "expected 'struct'")?;
    let _name: Token = expect(p, token.TK_IDENT(), "expected struct name")?;
    let _lbrace: Token = expect(p, token.TK_LBRACE(), "expected '{'")?;
    
    let mut count = 0;
    while check(p, token.TK_RBRACE()) == 0 && is_at_end(p) == 0 {
        let _field: int = parse_struct_field(p)?;
        count = count + 1;
    }
    
    let _rbrace: Token = expect(p, token.TK_RBRACE(), "expected '}'")?;
    return Result::Ok(count);
}

// ============================================================================
// Import/Export Parsing
// ============================================================================

fn parse_import(p: *Parser) -> Result<int, str> {
    let _import_tok: Token = expect(p, token.TK_IMPORT(), "expected 'import'")?;
    let _path: Token = expect(p, token.TK_IDENT(), "expected module path")?;
    
    while match_token(p, token.TK_DOT()) != 0 {
        let _part: Token = expect(p, token.TK_IDENT(), "expected module path part")?;
    }
    
    if match_token(p, token.TK_AS()) != 0 {
        let _alias: Token = expect(p, token.TK_IDENT(), "expected alias")?;
    }
    
    return Result::Ok(1);
}

fn parse_export(p: *Parser) -> Result<int, str> {
    let _export_tok: Token = expect(p, token.TK_EXPORT(), "expected 'export'")?;
    
    if check(p, token.TK_FN()) != 0 {
        return parse_function(p);
    }
    
    if check(p, token.TK_STRUCT()) != 0 {
        return parse_struct(p);
    }
    
    return Result::Err("expected function or struct after 'export'");
}

// ============================================================================
// Program Parsing
// ============================================================================

// ============================================================================
// Top-Level Parse Function
// ============================================================================

// Parse entire program - returns count of declarations
export fn parse_program(tokens: DynamicArray[Token], input: *char) -> Result<int, str> {
    let parser = Parser { 
        tokens: tokens, 
        current: 0,
        input: input
    };
    let p = &parser;
    
    let mut fn_count = 0;
    let mut struct_count = 0;
    let mut import_count = 0;
    
    while is_at_end(p) == 0 {
        if check(p, token.TK_IMPORT()) != 0 {
            let _imp: int = parse_import(p)?;
            import_count = import_count + 1;
        } else {
            if check(p, token.TK_EXPORT()) != 0 {
                let _exp: int = parse_export(p)?;
                fn_count = fn_count + 1;
            } else {
                if check(p, token.TK_FN()) != 0 {
                    let _func: int = parse_function(p)?;
                    fn_count = fn_count + 1;
                } else {
                    if check(p, token.TK_STRUCT()) != 0 {
                        let _st: int = parse_struct(p)?;
                        struct_count = struct_count + 1;
                    } else {
                        return Result::Err("unexpected token at top level");
                    }
                }
            }
        }
    }
    
    printf("Parse successful!\n");
    printf("  Functions: %d\n", fn_count);
    printf("  Structs: %d\n", struct_count);
    printf("  Imports: %d\n", import_count);
    
    return Result::Ok(fn_count + struct_count + import_count);
}
