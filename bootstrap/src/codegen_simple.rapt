// ============================================================================
// CODEGEN.RAPT - Bootstrap compiler code generator (output-direct version)
// ============================================================================

import token

extern fn printf(format: *char, ...) -> int;
extern fn strlen(s: *char) -> int;

// Print string from token span
fn print_token(input: *char, tok: Token) {
    let i = tok.span.start;
    while i < tok.span.end {
        printf("%c", input[i]);
        i = i + 1;
    }
}

// Emit C headers
fn emit_headers() {
    printf("#include <stdio.h>\n");
    printf("#include <stdlib.h>\n\n");
}

// Generate a simple function
fn generate_function(input: *char, toks: DynamicArray[Token], pos: int) -> int {
    let i = pos;
    let len = toks.length();
    
    // Skip export/extern
    if i < len && toks[i].kind == token.TK_EXPORT() {
        i = i + 1;
    }
    if i < len && toks[i].kind == token.TK_EXTERN() {
        // Skip extern functions
        i = i + 1;
        while i < len && toks[i].kind != token.TK_SEMI() {
            i = i + 1;
        }
        if i < len {
            i = i + 1;
        }
        return i;
    }
    
    // fn keyword
    if i < len && toks[i].kind == token.TK_FN() {
        i = i + 1;
    }
    
    // Always use int return type for simplicity
    printf("int ");
    
    // Function name
    if i < len && toks[i].kind == token.TK_IDENT() {
        print_token(input, toks[i]);
        i = i + 1;
    }
    
    // Parameters (just use empty for now)
    printf("() ");
    if i < len && toks[i].kind == token.TK_LPAREN() {
        i = i + 1;
        let depth = 1;
        while i < len && depth > 0 {
            if toks[i].kind == token.TK_LPAREN() {
                depth = depth + 1;
            }
            if toks[i].kind == token.TK_RPAREN() {
                depth = depth - 1;
            }
            i = i + 1;
        }
    }
    
    // Skip return type
    if i < len && toks[i].kind == token.TK_ARROW() {
        i = i + 1;
        if i < len {
            i = i + 1;
        }
    }
    
    // Body
    if i < len && toks[i].kind == token.TK_LBRACE() {
        printf("{\n");
        i = i + 1;
        
        let depth = 1;
        while i < len && depth > 0 {
            if toks[i].kind == token.TK_RBRACE() {
                depth = depth - 1;
                if depth > 0 {
                    printf("}\n");
                }
                i = i + 1;
            } else {
                if toks[i].kind == token.TK_RETURN() {
                    printf("    return ");
                    i = i + 1;
                    while i < len && toks[i].kind != token.TK_SEMI() {
                        print_token(input, toks[i]);
                        i = i + 1;
                    }
                    printf(";\n");
                    if i < len {
                        i = i + 1;
                    }
                } else {
                    if toks[i].kind == token.TK_LET() {
                        printf("    int ");
                        i = i + 1;
                        if i < len && toks[i].kind == token.TK_MUT() {
                            i = i + 1;
                        }
                        if i < len && toks[i].kind == token.TK_IDENT() {
                            print_token(input, toks[i]);
                            i = i + 1;
                        }
                        if i < len && toks[i].kind == token.TK_COLON() {
                            i = i + 1;
                            if i < len {
                                i = i + 1;
                            }
                        }
                        if i < len && toks[i].kind == token.TK_EQ() {
                            printf(" = ");
                            i = i + 1;
                            while i < len && toks[i].kind != token.TK_SEMI() {
                                print_token(input, toks[i]);
                                i = i + 1;
                            }
                        }
                        printf(";\n");
                        if i < len {
                            i = i + 1;
                        }
                    } else {
                        i = i + 1;
                    }
                }
            }
        }
        
        printf("}\n\n");
    }
    
    return i;
}

// Main codegen entry point
export fn emit_c_basic_stdout(input: *char, toks: DynamicArray[Token]) {
    emit_headers();
    
    let len = toks.length();
    let i = 0;
    
    while i < len {
        if toks[i].kind == token.TK_FN() || toks[i].kind == token.TK_EXPORT() || 
           toks[i].kind == token.TK_EXTERN() {
            i = generate_function(input, toks, i);
        } else {
            if toks[i].kind == token.TK_LET() {
                printf("static int ");
                i = i + 1;
                if i < len && toks[i].kind == token.TK_MUT() {
                    i = i + 1;
                }
                if i < len && toks[i].kind == token.TK_IDENT() {
                    print_token(input, toks[i]);
                    i = i + 1;
                }
                if i < len && toks[i].kind == token.TK_COLON() {
                    i = i + 1;
                    if i < len {
                        i = i + 1;
                    }
                }
                if i < len && toks[i].kind == token.TK_EQ() {
                    printf(" = ");
                    i = i + 1;
                    while i < len && toks[i].kind != token.TK_SEMI() {
                        print_token(input, toks[i]);
                        i = i + 1;
                    }
                }
                printf(";\n");
                if i < len {
                    i = i + 1;
                }
            } else {
                i = i + 1;
            }
        }
    }
}

export fn emit_c_to_file(input: *char, toks: DynamicArray[Token], output_file: *char) {
    emit_c_basic_stdout(input, toks);
}
